{"version":3,"sources":["webpack:///./components/editor/paragraph/paragraph.css","webpack:///./components/editor/add_button/addButton.css","webpack:///./routes/home/style.css","webpack:///./components/button/button.tsx","webpack:///./components/editor/add_button/addBoxIcon.tsx","webpack:///./components/editor/add_button/addButton.tsx","webpack:///./components/sortable_card/sortableCard.tsx","webpack:///./components/editor/paragraph/deleteIcon.tsx","webpack:///./components/editor/paragraph/reorderIcon.tsx","webpack:///./components/editor/paragraph/paragraph.tsx","webpack:///./components/editor/preview/preview.tsx","webpack:///./components/editor/editor.tsx","webpack:///./routes/home/index.tsx","webpack:///internal/dom-utils.ts","webpack:///internal/drag-utils.ts","webpack:///index.ts","webpack:///internal/constants.ts","webpack:///internal/feature-detection.ts","webpack:///internal/drag-data-store.ts","webpack:///internal/drag-operation-controller.ts","webpack:///./components/card/card.css","webpack:///scroll-behaviour.ts","webpack:///./components/button/button.css","webpack:///./components/editor/editor.css","webpack:///./components/styles/japanese.css","webpack:///./components/editor/preview/preview.css"],"names":["module","exports","Button","props","className","style","btn","type","onClick","children","AddBoxIcon","xmlns","height","viewBox","width","d","AddButton","dispatch","useContext","EditorContext","useCallback","addParagraph","buttonStyle","SortableCard","ref","useRef","dragContext","DragContext","onDragStart","e","dataTransfer","Error","dropEffect","effectAllowed","data","index","onMovieStart","onDragEnd","onMoveEnd","onDrag","current","dragIndex","hoverIndex","hoverBoundingRect","getBoundingClientRect","hoverMiddleY","bottom","top","hoverClientY","clientY","onMove","draggable","onDragOver","DeleteIcon","ReorderIcon","Paragraph","state","p","paragraphs","id","bindDispatch","fn","args","ParagraphPresenter","text","isSorting","isDragging","draggingIndex","focus","lastAdded","onChange","updateParagraphText","onDelete","deleteParagraph","onMoveStart","startMoving","moveParagraph","endMove","currentTarget","value","preventDefault","textArea","useEffect","textAreaId","cardStyle","card","pStyle","paragraph","data-is-editing","data-is-dragging","move","textarea","name","onKeyUp","placeholder","count","aria-label","length","delete","tabIndex","Preview","useMemo","list","map","lines","split","reduce","acc","i","key","jpStyle","preview","Editor","editor","showsPreview","window","polyfill","dragImageTranslateOverride","scrollBehaviourDragImageTranslateOverride","createContext","Home","home","object","tagName","ev","handler","passive","document","addEventListener","supportsPassive","removeEventListener","el","event","capture","options","off","array","s","v","touchEvent","touchIdentifier","changedTouches","identifier","coordinateProp","outPoint","pageXs","pageYs","touches","touch","push","x","average","y","element","pnt","originalTransforms","offset","centerOnCoordinates","parseInt","offsetWidth","offsetHeight","translate","TRANSFORM_CSS_VENDOR_PREFIXES","sourceNode","ALLOWED_EFFECTS","DROP_EFFECTS","indexOf","nodeType","dragEvent","targetElement","dataStore","cancelable","relatedTarget","leaveEvt","dndEvent","Event","bubbles","screenX","screenY","clientX","pageX","pageY","targetRect","offsetX","left","offsetY","cancelled","dispatchEvent","mode","activeDragOperation","dragTarget","config","tryFindDraggableTarget","DragOperationController","dragOperationEnded","err","evt","target","onReleasedItem","end","cancel","scroll","CustomEvent","EVENT_PREFIX","EVENT_DRAG_DRAGSTART_CANCEL","clearTimeout","timer","EVENT_DRAG_DRAGSTART_PENDING","setTimeout","onTouchstart","holdToDrag","onEvt","_config","defaultActionOverride","CLASS_PREFIX","supportsPassiveEventListeners","opts","Object","defineProperty","get","_dataStore","_setDragImageHandler","this","DataTransfer","_dropEffect","freeze","types","format","splice","image","_initialEvent","_sourceNode","_dragOperationEndedCb","_lastTouchEvent","_initialTouch","_touchMoveHandler","_onTouchMove","bind","_touchEndOrCancelHandler","_onTouchEndOrCancel","addDocumentListener","_dragOperationState","_currentDragOperation","_dragDataStore","_currentHotspotCoordinates","_dragImagePageCoordinates","dragImageSrc","_dataTransfer","_this","_dragImageOffset","dispatchDragEvent","_cleanup","updateCentroidCoordinatesOfTouchesIn","dragImage","dragImageSetup","_dragImageTransforms","prefix","transform","replace","position","zIndex","classList","add","_dragImage","dragImageOffset","dragImageCenterOnTouch","cs","getComputedStyle","marginLeft","marginTop","translateElementToPoint","body","appendChild","_iterationIntervalId","setInterval","_iterationLock","_dragAndDropProcessModelIteration","iterationInterval","clearInterval","removeDocumentListener","parentNode","removeChild","isTouchIdentifierContainedInTouchEvent","startDrag","dragStartConditionOverride","_setup","handledDragImageTranslate_1","_immediateUserSelection","undefined","previousDragOperation","dragCancelled","_dragOperationEnded","sourceEl","dragImageTransforms","transitionEndCb","visibility","display","csDragImage","durationInS","parseFloat","transitionDuration","isNaN","rect","scrollLeft","documentElement","scrollTop","delayInS","transitionDelay","durationInMs","Math","round","_finishDragOperation","newUserSelection","elementFromPoint","previousTargetElement","_currentDropTarget","determineDropEffect","determineDragOperation","isDOMElement","remove","dragFailed","getAttribute","cloneNode","srcNode","dstNode","csName","setProperty","getPropertyValue","getPropertyPriority","pointerEvents","removeAttribute","nodeName","canvasSrc","canvasDst","canvasSrcImgData","getContext","getImageData","putImageData","hasChildNodes","childNodes","prepareNodeCopyAsDragImage","override","keys","forEach","forceApply","detectedFeatures","features","dragEvents","userAgentSupportingNativeDnD","isBlinkEngine","test","navigator","userAgent","onDelayTouchstart","t","axis","isTopLevelEl","clientLeft","clientTop","bounds","innerWidth","innerHeight","clientWidth","clientHeight","prop","isTopLevel","arguments","scrollHeight","overflowY","scrollWidth","overflowX","currentCoordinate","size","threshold","scrollIntention","abs","scrollBounds","currentScrollOffset","scrollX","scrollY","_scrollAnimationFrameId","requestAnimationFrame","scrollAnimation","scrollDiffX","scrollDiffY","_scrollableParent","_scrollIntentions","horizontal","_options","_dynamicVelocity","getSetElementScroll","vertical","_translateDragImageFn","updateScrollIntentions","_currentCoordinates","scheduleScrollAnimation","currentCoordinates","scrollableParent","scrollIntentions","dynamicVelocity","scrollableParentBounds","getElementViewportOffset","getElementViewportSize","currentCoordinatesOffset","determineScrollIntention","isScrollEndReached","determineDynamicVelocity","_hoveredElement","velocity","multiplier","hoveredElement","translateDragImageFn","isScrollable","findScrollableParent","cancelAnimationFrame"],"mappings":"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","file":"route-home.chunk.56a62.esm.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"paragraph\":\"paragraph__3XZVW\",\"textarea\":\"textarea__lochO\",\"label-text\":\"label-text__3th0i\",\"count\":\"count__1uRWR\",\"edit-form\":\"edit-form__1rRzC\",\"delete\":\"delete__3Sp8N\",\"move\":\"move__3cboQ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"add-button\":\"add-button__1KgZw\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"home\":\"home__5d1wS\"};","import { ComponentChildren, h } from \"preact\";\nimport style from \"./button.css\";\n\nexport interface ButtonProps {\n  className?: string;\n  type?: \"primary\";\n  onClick?: (e: MouseEvent) => void;\n  children?: ComponentChildren;\n}\n\nexport function Button(props: ButtonProps) {\n  let className = `${style.btn} ${props.className}`;\n  if (props.type === \"primary\") {\n    className += ` ${style[\"btn-primary\"]}`;\n  }\n  return (\n    <button onClick={props.onClick} className={className}>\n      {props.children}\n    </button>\n  );\n}\n","import { h } from \"preact\";\n\nexport function AddBoxIcon(props: { className?: string }) {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      width=\"24\"\n      {...props}\n    >\n      <path d=\"M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z\" />\n    </svg>\n  );\n}\n","import { h } from \"preact\";\nimport { Button } from \"../../button/button\";\nimport { AddBoxIcon } from \"./addBoxIcon\";\nimport style from \"./addButton.css\";\nimport buttonStyle from \"../../button/button.css\";\nimport { useCallback, useContext } from \"preact/hooks\";\nimport { addParagraph, EditorContext } from \"../editorState\";\n\nexport function AddButton() {\n  const { dispatch } = useContext(EditorContext);\n  const onClick = useCallback(() => {\n    dispatch(addParagraph());\n  }, []);\n  return (\n    <Button className={style[\"add-button\"]} type=\"primary\" onClick={onClick}>\n      <AddBoxIcon className={buttonStyle[\"btn-icon\"]} /> <span>追加する</span>\n    </Button>\n  );\n}\n","import \"mobile-drag-drop/default.css\";\nimport { polyfill } from \"mobile-drag-drop\";\nimport { scrollBehaviourDragImageTranslateOverride } from \"mobile-drag-drop/scroll-behaviour\";\nimport { ComponentChildren, createContext, h } from \"preact\";\nimport { useCallback, useContext, useRef } from \"preact/hooks\";\n\nif (typeof window !== \"undefined\") {\n  polyfill({\n    dragImageTranslateOverride: scrollBehaviourDragImageTranslateOverride,\n  });\n}\n\ninterface SortableCardProps {\n  index: number;\n  onMovieStart?: (index: number) => void;\n  onMove?: (dragIndex: number, dropIndex: number) => void;\n  onMoveEnd?: () => void;\n  className?: string;\n  children?: ComponentChildren;\n}\n\ntype DragInfo = {\n  data: {\n    index: number;\n  } | null;\n};\nconst DragContext = createContext<DragInfo>({ data: null });\n\nexport function SortableCard(props: SortableCardProps) {\n  const ref = useRef<HTMLDivElement | null>(null);\n  //const [isDragging, setDraggingState] = useState(false);\n  const dragContext = useContext(DragContext);\n  const onDragStart = useCallback(\n    (e: DragEvent) => {\n      const dataTransfer = e.dataTransfer;\n      if (!dataTransfer) {\n        throw new Error();\n      }\n      dataTransfer.dropEffect = \"move\";\n      dataTransfer.effectAllowed = \"move\";\n      dragContext.data = { index: props.index };\n      props.onMovieStart?.(props.index);\n    },\n    [props.index]\n  );\n  const onDragEnd = useCallback(() => {\n    props.onMoveEnd?.();\n  }, [props.onMoveEnd]);\n  const onDrag = useCallback(\n    (e: DragEvent) => {\n      if (!ref.current || !e.dataTransfer) {\n        return;\n      }\n      if (!dragContext.data) {\n        return;\n      }\n      const dragIndex = dragContext.data.index;\n      const hoverIndex = props.index;\n      // Don't replace items with themselves\n      if (dragIndex === hoverIndex) {\n        return;\n      }\n      // Determine rectangle on screen\n      const hoverBoundingRect = ref.current?.getBoundingClientRect();\n      // Get vertical middle\n      const hoverMiddleY =\n        (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n      // Determine mouse position\n      const clientOffset = { x: e.clientX, y: e.clientY };\n      // Get pixels to the top\n      const hoverClientY = clientOffset.y - hoverBoundingRect.top;\n      // Only perform the move when the mouse has crossed half of the items height\n      // When dragging downwards, only move when the cursor is below 50%\n      // When dragging upwards, only move when the cursor is above 50%\n      // Dragging downwards\n      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {\n        return;\n      }\n      // Dragging upwards\n      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {\n        return;\n      }\n      // Time to actually perform the action\n      props.onMove?.(dragIndex, hoverIndex);\n      // Note: we're mutating the monitor item here!\n      // Generally it's better to avoid mutations,\n      // but it's good here for the sake of performance\n      // to avoid expensive index searches.\n      dragContext.data.index = hoverIndex;\n    },\n    [props.index]\n  );\n  return (\n    <div\n      ref={ref}\n      className={props.className}\n      draggable\n      onDragStart={onDragStart}\n      onDragOver={onDrag}\n      onDragEnd={onDragEnd}\n    >\n      {props.children}\n    </div>\n  );\n}\n","import { h } from \"preact\";\n\nexport function DeleteIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      width=\"24\"\n    >\n      <path d=\"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z\" />\n    </svg>\n  );\n}\n","import { h } from \"preact\";\n\nexport function ReorderIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      width=\"24\"\n    >\n      <path d=\"M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z\" />\n    </svg>\n  );\n}\n","import { h } from \"preact\";\nimport { useCallback, useContext, useEffect, useRef } from \"preact/hooks\";\nimport { SortableCard } from \"../../sortable_card/sortableCard\";\nimport { DeleteIcon } from \"./deleteIcon\";\nimport pStyle from \"./paragraph.css\";\nimport cardStyle from \"../../card/card.css\";\nimport { ReorderIcon } from \"./reorderIcon\";\nimport {\n  deleteParagraph,\n  EditorAction,\n  EditorContext,\n  endMove,\n  moveParagraph,\n  startMoving,\n  updateParagraphText,\n} from \"../editorState\";\n\ninterface ParagraphProps {\n  id: string;\n  index: number;\n}\n\nexport function Paragraph(props: ParagraphProps) {\n  const { state, dispatch } = useContext(EditorContext);\n  const p = state.paragraphs[props.id];\n  if (!p) {\n    return null;\n  }\n  const bindDispatch = useCallback(function <\n    A extends unknown[],\n    B extends EditorAction\n  >(fn: (...args: A) => B) {\n    return useCallback((...args: A) => {\n      dispatch(fn(...args));\n    }, []);\n  },\n  []);\n  return (\n    <ParagraphPresenter\n      id={props.id}\n      index={props.index}\n      text={p.text}\n      isSorting={state.isSorting}\n      isDragging={state.draggingIndex === props.index}\n      focus={props.index === state.lastAdded}\n      onChange={bindDispatch(updateParagraphText)}\n      onDelete={bindDispatch(deleteParagraph)}\n      onMoveStart={bindDispatch(startMoving)}\n      onMove={bindDispatch(moveParagraph)}\n      onMoveEnd={bindDispatch(endMove)}\n    />\n  );\n}\n\ninterface ParagraphPresenterProps {\n  id: string;\n  index: number;\n  text: string;\n  isSorting: boolean;\n  isDragging: boolean;\n  focus: boolean;\n  onChange?(text: string, id: string): void;\n  onDelete?(id: string): void;\n  onMoveStart?(index: number): void;\n  onMove?(dragIndex: number, hoverIndex: number): void;\n  onMoveEnd?(): void;\n}\n\nexport function ParagraphPresenter(props: ParagraphPresenterProps) {\n  const onChange = useCallback(\n    (e: Event) => {\n      props.onChange?.((e.currentTarget as HTMLInputElement).value, props.id);\n    },\n    [props.onChange, props.id]\n  );\n  const onDelete = useCallback(\n    (e: Event) => {\n      e.preventDefault();\n      props.onDelete?.(props.id);\n    },\n    [props.id]\n  );\n  const textArea = useRef<HTMLTextAreaElement | null>(null);\n  useEffect(() => {\n    if (props.focus) {\n      textArea.current?.focus();\n    }\n  }, [props.focus]);\n  const textAreaId = `paragraph-${props.index}`;\n  return (\n    <li\n      className={`${cardStyle.card} ${pStyle.paragraph}`}\n      data-is-editing={props.isSorting ? \"true\" : \"false\"}\n      data-is-dragging={props.isDragging ? \"true\" : \"false\"}\n    >\n      <SortableCard\n        index={props.index}\n        className={`${pStyle.move} ${pStyle[\"edit-form\"]}`}\n        onMovieStart={props.onMoveStart}\n        onMove={props.onMove}\n        onMoveEnd={props.onMoveEnd}\n      >\n        <ReorderIcon />\n      </SortableCard>\n      <label className={pStyle.textarea}>\n        <textarea\n          id={textAreaId}\n          name={`paragraph-${props.index}`}\n          ref={textArea}\n          value={props.text}\n          onKeyUp={onChange}\n          placeholder={props.index === 0 ? \"文章を入力\" : \"\"}\n        />\n        <div className={pStyle.count} aria-label=\"文字カウント\">\n          {props.text.length}\n        </div>\n        <span className={pStyle[\"label-text\"]}>段落</span>\n      </label>\n      <div className={`${pStyle.delete} ${pStyle[\"edit-form\"]}`}>\n        <button\n          onClick={onDelete}\n          aria-label=\"削除ボタン\"\n          tabIndex={props.isSorting ? 0 : -1}\n        >\n          <DeleteIcon />\n        </button>\n      </div>\n    </li>\n  );\n}\n","import { h } from \"preact\";\nimport { useMemo } from \"preact/hooks\";\nimport { Paragraph } from \"../editorState\";\nimport style from \"./preview.css\";\nimport cardStyle from \"../../card/card.css\";\nimport jpStyle from \"../../styles/japanese.css\";\nimport { JSXInternal } from \"preact/src/jsx\";\n\nexport type PreviewProps = {\n  list: string[];\n  paragraph: Record<string, Paragraph>;\n};\n\nexport default function Preview(props: PreviewProps) {\n  const text = useMemo(() => {\n    return props.list.map((id) => {\n      const lines = (props.paragraph[id]?.text ?? \"\").split(\"\\n\");\n      const text = lines.reduce<(JSXInternal.Element | string)[]>(\n        (acc, text, i) => {\n          if (i === lines.length - 1) {\n            return [...acc, text];\n          } else {\n            return [...acc, text, <br key={`br-${i}`} />];\n          }\n        },\n        []\n      );\n      return (\n        <p\n          className={`${jpStyle[\"japanese-text\"]}`}\n          key={`preview-paragraph-${id}`}\n        >\n          {text}\n        </p>\n      );\n    });\n  }, [props.list, props.paragraph]);\n  return <div className={`${style.preview} ${cardStyle.card}`}>{text}</div>;\n}\n","import { h } from \"preact\";\nimport { useContext } from \"preact/hooks\";\nimport { AddButton } from \"./add_button/addButton\";\nimport style from \"./editor.css\";\nimport { EditorContext } from \"./editorState\";\nimport { Paragraph } from \"./paragraph/paragraph\";\nimport Preview from \"./preview/preview\";\n\nexport function Editor() {\n  const { state } = useContext(EditorContext);\n  return (\n    <div className={style.editor}>\n      <div>\n        <ul>\n          {state.list.map((id, index) => {\n            const p = state.paragraphs[id];\n            return (\n              p && (\n                <Paragraph key={`paragraph-${p.id}`} id={p.id} index={index} />\n              )\n            );\n          })}\n          <li>\n            <AddButton />\n          </li>\n        </ul>\n      </div>\n      {state.showsPreview && (\n        <div>\n          <Preview list={state.list} paragraph={state.paragraphs} />\n        </div>\n      )}\n    </div>\n  );\n}\n","import { FunctionalComponent, h } from \"preact\";\nimport { Editor } from \"../../components/editor/editor\";\nimport style from \"./style.css\";\n\nconst Home: FunctionalComponent = () => {\n  return (\n    <div className={style.home}>\n      <Editor />\n    </div>\n  );\n};\n\nexport default Home;\n","import { CLASS_DRAG_IMAGE_SNAPBACK } from \"./constants\";\nimport { supportsPassiveEventListener } from \"./feature-detection\";\n\n// evaluate once on startup\nconst supportsPassive = supportsPassiveEventListener();\n\nexport interface Point {\n    x:number;\n    y:number;\n}\n\nexport function isDOMElement( object:Element ) {\n    return object && object.tagName;\n}\n\nexport function addDocumentListener( ev:string, handler:EventListener, passive:boolean = true ) {\n    document.addEventListener( ev, handler, supportsPassive ? { passive: passive } : false );\n}\n\nexport function removeDocumentListener( ev:string, handler:EventListener ) {\n    document.removeEventListener( ev, handler );\n}\n\nexport function onEvt(el:EventTarget, event:string, handler:EventListener, capture:boolean = false) {\n\n    const options = supportsPassive ? {passive: true, capture: capture} : capture;\n\n    el.addEventListener(event, handler, options);\n\n    return {\n        off() {\n            el.removeEventListener(event, handler, options as any);\n        }\n    };\n}\n\nfunction prepareNodeCopyAsDragImage( srcNode:HTMLElement, dstNode:HTMLElement ) {\n\n    // Is this node an element?\n    if( srcNode.nodeType === 1 ) {\n\n        // Clone the style\n        const cs = getComputedStyle( srcNode );\n        for( let i = 0; i < cs.length; i++ ) {\n            const csName = cs[ i ];\n            dstNode.style.setProperty( csName, cs.getPropertyValue( csName ), cs.getPropertyPriority( csName ) );\n        }\n\n        // no interaction with the drag image, pls! this is also important to make the drag image transparent for hit-testing\n        // hit testing is done in the drag and drop iteration to find the element the user currently is hovering over while dragging.\n        // if pointer-events is not none or a browser does behave in an unexpected way than the hit test transparency on the drag image\n        // will break\n        dstNode.style.pointerEvents = \"none\";\n\n        // Remove any potential conflict attributes\n        dstNode.removeAttribute( \"id\" );\n        dstNode.removeAttribute( \"class\" );\n        dstNode.removeAttribute( \"draggable\" );\n\n        // canvas elements need special handling by copying canvas image data\n        if( dstNode.nodeName === \"CANVAS\" ) {\n\n            const canvasSrc = srcNode as HTMLCanvasElement;\n            const canvasDst = dstNode as HTMLCanvasElement;\n\n            const canvasSrcImgData = canvasSrc.getContext( \"2d\" ).getImageData( 0, 0, canvasSrc.width, canvasSrc.height );\n\n            canvasDst.getContext( \"2d\" ).putImageData( canvasSrcImgData, 0, 0 );\n        }\n    }\n\n    // Do the same for the children\n    if( srcNode.hasChildNodes() ) {\n\n        for( let i = 0; i < srcNode.childNodes.length; i++ ) {\n\n            prepareNodeCopyAsDragImage( <HTMLElement>srcNode.childNodes[ i ], <HTMLElement>dstNode.childNodes[ i ] );\n        }\n    }\n}\n\nexport function createDragImage( sourceNode:HTMLElement ):HTMLElement {\n\n    const dragImage = <HTMLElement>sourceNode.cloneNode( true );\n\n    // this removes any id's and stuff that could interfere with drag and drop\n    prepareNodeCopyAsDragImage( sourceNode, dragImage );\n\n    return dragImage;\n}\n\nfunction average( array:Array<number> ) {\n    if( array.length === 0 ) {\n        return 0;\n    }\n    return array.reduce( (function( s, v ) {\n        return v + s;\n    }), 0 ) / array.length;\n}\n\nexport function isTouchIdentifierContainedInTouchEvent( touchEvent:TouchEvent, touchIdentifier:number ) {\n    for( let i = 0; i < touchEvent.changedTouches.length; i++ ) {\n        const touch = touchEvent.changedTouches[ i ];\n        if( touch.identifier === touchIdentifier ) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Calc center of polygon spanned by multiple touches in page (full page size, with hidden scrollable area) coordinates\n * or in viewport (screen coordinates) coordinates.\n */\nexport function updateCentroidCoordinatesOfTouchesIn( coordinateProp:\"page\" | \"client\", event:TouchEvent, outPoint:Point ):void {\n    const pageXs:Array<number> = [], pageYs:Array<number> = [];\n    for( let i = 0; i < event.touches.length; i++ ) {\n        const touch = event.touches[ i ];\n        pageXs.push( touch[ coordinateProp + \"X\" ] );\n        pageYs.push( touch[ coordinateProp + \"Y\" ] );\n    }\n    outPoint.x = average( pageXs );\n    outPoint.y = average( pageYs );\n}\n\n// cross-browser css transform property prefixes\nconst TRANSFORM_CSS_VENDOR_PREFIXES = [ \"\", \"-webkit-\" ];\n\nexport function extractTransformStyles( sourceNode:HTMLElement ):string[] {\n\n    return TRANSFORM_CSS_VENDOR_PREFIXES.map( function( prefix:string ) {\n\n        let transform = sourceNode.style[ prefix + \"transform\" ];\n\n        if( !transform || transform === \"none\" ) {\n            return \"\";\n        }\n\n        // removes translate(x,y)\n        return transform.replace( /translate\\(\\D*\\d+[^,]*,\\D*\\d+[^,]*\\)\\s*/g, \"\" );\n    } );\n}\n\nexport function translateElementToPoint( element:HTMLElement, pnt:Point, originalTransforms:string[], offset?:Point, centerOnCoordinates = true ):void {\n\n    let x = pnt.x, y = pnt.y;\n\n    if( offset ) {\n        x += offset.x;\n        y += offset.y;\n    }\n\n    if( centerOnCoordinates ) {\n        x -= (parseInt( <any>element.offsetWidth, 10 ) / 2);\n        y -= (parseInt( <any>element.offsetHeight, 10 ) / 2);\n    }\n\n    // using translate3d for max performance\n    const translate = \"translate3d(\" + x + \"px,\" + y + \"px, 0)\";\n\n    for( let i = 0; i < TRANSFORM_CSS_VENDOR_PREFIXES.length; i++ ) {\n        const transformProp = TRANSFORM_CSS_VENDOR_PREFIXES[ i ] + \"transform\";\n        element.style[ transformProp ] = translate + \" \" + originalTransforms[ i ];\n    }\n}\n\n/**\n * calculates the coordinates of the drag source and transitions the drag image to those coordinates.\n * the drag operation is finished after the transition has ended.\n */\nexport function applyDragImageSnapback( sourceEl:HTMLElement, dragImage:HTMLElement, dragImageTransforms:string[], transitionEndCb:Function ):void {\n\n    const cs = getComputedStyle( sourceEl );\n\n    if( cs.visibility === \"hidden\" || cs.display === \"none\" ) {\n        console.log( \"dnd-poly: source node is not visible. skipping snapback transition.\" );\n        // shortcut to end the drag operation\n        transitionEndCb();\n        return;\n    }\n    // add class containing transition rules\n    dragImage.classList.add( CLASS_DRAG_IMAGE_SNAPBACK );\n\n    const csDragImage = getComputedStyle( dragImage );\n    const durationInS = parseFloat( csDragImage.transitionDuration );\n    if( isNaN( durationInS ) || durationInS === 0 ) {\n        console.log( \"dnd-poly: no transition used - skipping snapback\" );\n        transitionEndCb();\n        return;\n    }\n\n    console.log( \"dnd-poly: starting dragimage snap back\" );\n\n    // calc source node position\n    const rect = sourceEl.getBoundingClientRect();\n\n    const pnt:Point = {\n        x: rect.left,\n        y: rect.top\n    };\n\n    // add scroll offset of document\n    pnt.x += (document.body.scrollLeft || document.documentElement.scrollLeft);\n    pnt.y += (document.body.scrollTop || document.documentElement.scrollTop);\n\n    //TODO this sometimes fails to calculate the correct origin position.. find out when exactly and how to detect\n    pnt.x -= parseInt( cs.marginLeft, 10 );\n    pnt.y -= parseInt( cs.marginTop, 10 );\n\n    const delayInS = parseFloat( csDragImage.transitionDelay );\n    const durationInMs = Math.round( (durationInS + delayInS) * 1000 );\n\n    // apply the translate\n    translateElementToPoint( dragImage, pnt, dragImageTransforms, undefined, false );\n\n    setTimeout( transitionEndCb, durationInMs );\n}\n","import { ALLOWED_EFFECTS, DROP_EFFECT, DROP_EFFECTS, EFFECT_ALLOWED } from \"./constants\";\nimport { DataTransfer, DragDataStore, DragDataStoreMode } from \"./drag-data-store\";\n\n/**\n * Search for a possible draggable item upon an event that can initialize a drag operation.\n * Can be overridden in polyfill config.\n */\nexport function tryFindDraggableTarget( event:TouchEvent ):HTMLElement | undefined {\n\n    //1. Determine what is being dragged, as follows:\n\n    // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n    // If the drag operation was invoked on a selection, then it is the selection that is being dragged.\n    //if( (<Element>event.target).nodeType === 3 ) {\n    //\n    //    config.log( \"drag on text\" );\n    //    return <Element>event.target;\n    //}\n    //Otherwise, if the drag operation was invoked on a Document, it is the first element, going up the ancestor chain, starting at the node that the\n    // user tried to drag, that has the IDL attribute draggable set to true.\n    //else {\n\n    let el = <HTMLElement>event.target;\n\n    do {\n        if( el.draggable === false ) {\n            continue;\n        }\n        if( el.draggable === true ) {\n            return el;\n        }\n        if( el.getAttribute\n            && el.getAttribute( \"draggable\" ) === \"true\" ) {\n            return el;\n        }\n    } while( (el = <HTMLElement>el.parentNode) && el !== document.body );\n}\n\n/**\n * Implements \"6.\" in the processing steps defined for a dnd event\n * https://html.spec.whatwg.org/multipage/interaction.html#dragevent\n */\nexport function determineDropEffect( effectAllowed:string, sourceNode:Element ) {\n\n    // uninitialized\n    if( !effectAllowed ) {\n\n        // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n        //if( sourceNode.nodeType === 1 ) {\n        //\n        //return \"move\";\n        //}\n\n        // link\n        if( sourceNode.nodeType === 3 && (<HTMLElement>sourceNode).tagName === \"A\" ) {\n            return DROP_EFFECTS[ DROP_EFFECT.LINK ];\n        }\n\n        // copy\n        return DROP_EFFECTS[ DROP_EFFECT.COPY ];\n    }\n\n    // none\n    if( effectAllowed === ALLOWED_EFFECTS[ EFFECT_ALLOWED.NONE ] ) {\n        return DROP_EFFECTS[ DROP_EFFECT.NONE ];\n    }\n    // copy or all\n    if( effectAllowed.indexOf( ALLOWED_EFFECTS[ EFFECT_ALLOWED.COPY ] ) === 0 || effectAllowed === ALLOWED_EFFECTS[ EFFECT_ALLOWED.ALL ] ) {\n        return DROP_EFFECTS[ DROP_EFFECT.COPY ];\n    }\n    // link\n    if( effectAllowed.indexOf( ALLOWED_EFFECTS[ EFFECT_ALLOWED.LINK ] ) === 0 ) {\n        return DROP_EFFECTS[ DROP_EFFECT.LINK ];\n    }\n    // move\n    if( effectAllowed === ALLOWED_EFFECTS[ EFFECT_ALLOWED.MOVE ] ) {\n        return DROP_EFFECTS[ DROP_EFFECT.MOVE ];\n    }\n\n    // copy\n    return DROP_EFFECTS[ DROP_EFFECT.COPY ];\n}\n\nfunction createDragEventFromTouch( targetElement:Element,\n                                   e:TouchEvent,\n                                   type:string,\n                                   cancelable:boolean,\n                                   window:Window,\n                                   dataTransfer:DataTransfer,\n                                   relatedTarget:Element = null ) {\n\n    const touch:Touch = e.changedTouches[ 0 ];\n\n    const dndEvent:DragEvent = new Event( type, {\n        bubbles: true,\n        cancelable: cancelable\n    } ) as DragEvent;\n\n    // cast our polyfill\n    (dndEvent as any).dataTransfer = dataTransfer as any;\n    (dndEvent as any).relatedTarget = relatedTarget;\n\n    // set the coordinates\n    (dndEvent as any).screenX = touch.screenX;\n    (dndEvent as any).screenY = touch.screenY;\n    (dndEvent as any).clientX = touch.clientX;\n    (dndEvent as any).clientY = touch.clientY;\n    (dndEvent as any).pageX = touch.pageX;\n    (dndEvent as any).pageY = touch.pageY;\n\n    const targetRect = targetElement.getBoundingClientRect();\n    (dndEvent as any).offsetX = dndEvent.clientX - targetRect.left;\n    (dndEvent as any).offsetY = dndEvent.clientY - targetRect.top;\n\n    return dndEvent;\n}\n\n/**\n * Reference https://html.spec.whatwg.org/multipage/interaction.html#dndevents\n */\nexport function dispatchDragEvent( dragEvent:string,\n                                   targetElement:Element,\n                                   touchEvent:TouchEvent,\n                                   dataStore:DragDataStore,\n                                   dataTransfer:DataTransfer,\n                                   cancelable:boolean = true,\n                                   relatedTarget:Element | null = null ):boolean {\n\n    console.log( \"dnd-poly: dispatching \" + dragEvent );\n\n    // if( DEBUG ) {\n    //     const debug_class = CLASS_PREFIX + \"debug\",\n    //         debug_class_event_target = CLASS_PREFIX + \"event-target\",\n    //         debug_class_event_related_target = CLASS_PREFIX + \"event-related-target\";\n    //     targetElement.classList.add( debug_class );\n    //     targetElement.classList.add( debug_class_event_target );\n    //     if( relatedTarget ) {\n    //         relatedTarget.classList.add( debug_class );\n    //         relatedTarget.classList.add( debug_class_event_related_target );\n    //     }\n    // }\n\n    const leaveEvt = createDragEventFromTouch( targetElement, touchEvent, dragEvent, cancelable, document.defaultView, dataTransfer, relatedTarget );\n    const cancelled = !targetElement.dispatchEvent( leaveEvt );\n\n    dataStore.mode = DragDataStoreMode._DISCONNECTED;\n\n    // if( DEBUG ) {\n    //     const debug_class_event_target = CLASS_PREFIX + \"event-target\",\n    //         debug_class_event_related_target = CLASS_PREFIX + \"event-related-target\";\n    //     targetElement.classList.remove( debug_class_event_target );\n    //     if( relatedTarget ) {\n    //         relatedTarget.classList.remove( debug_class_event_related_target );\n    //     }\n    // }\n\n    return cancelled;\n}\n\n/**\n * according to https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n */\nexport function determineDragOperation( effectAllowed:string, dropEffect:string ):string {\n\n    // unitialized or all\n    if( !effectAllowed || effectAllowed === ALLOWED_EFFECTS[ 7 ] ) {\n        return dropEffect;\n    }\n\n    if( dropEffect === DROP_EFFECTS[ DROP_EFFECT.COPY ] ) {\n        if( effectAllowed.indexOf( DROP_EFFECTS[ DROP_EFFECT.COPY ] ) === 0 ) {\n            return DROP_EFFECTS[ DROP_EFFECT.COPY ];\n        }\n    }\n    else if( dropEffect === DROP_EFFECTS[ DROP_EFFECT.LINK ] ) {\n        if( effectAllowed.indexOf( DROP_EFFECTS[ DROP_EFFECT.LINK ] ) === 0 || effectAllowed.indexOf( \"Link\" ) > -1 ) {\n            return DROP_EFFECTS[ DROP_EFFECT.LINK ];\n        }\n    }\n    else if( dropEffect === DROP_EFFECTS[ DROP_EFFECT.MOVE ] ) {\n        if( effectAllowed.indexOf( DROP_EFFECTS[ DROP_EFFECT.MOVE ] ) === 0 || effectAllowed.indexOf( \"Move\" ) > -1 ) {\n            return DROP_EFFECTS[ DROP_EFFECT.MOVE ];\n        }\n    }\n\n    return DROP_EFFECTS[ DROP_EFFECT.NONE ];\n}\n","import { addDocumentListener, createDragImage, onEvt, Point } from \"./internal/dom-utils\";\nimport { DragOperationController, DragOperationState } from \"./internal/drag-operation-controller\";\nimport { tryFindDraggableTarget } from \"./internal/drag-utils\";\nimport { detectFeatures } from \"./internal/feature-detection\";\nimport { EVENT_DRAG_DRAGSTART_PENDING, EVENT_DRAG_DRAGSTART_CANCEL } from \"./internal/constants\";\n\n// default config\nconst config:Config = {\n    iterationInterval: 150,\n    tryFindDraggableTarget: tryFindDraggableTarget,\n    dragImageSetup: createDragImage,\n    elementFromPoint: function( x, y ) { return document.elementFromPoint( x, y ); }\n};\n\n// reference to the currently active drag operation\nlet activeDragOperation:DragOperationController;\n\n/**\n * event handler for initial touch events that possibly start a drag and drop operation.\n */\nfunction onTouchstart( e:TouchEvent ) {\n\n    console.log( \"dnd-poly: global touchstart\" );\n\n    // From the moment that the user agent is to initiate the drag-and-drop operation,\n    // until the end of the drag-and-drop operation, device input events (e.g. mouse and keyboard events) must be suppressed.\n\n    // only allow one drag operation at a time\n    if( activeDragOperation ) {\n        console.log( \"dnd-poly: drag operation already active\" );\n        return;\n    }\n\n    let dragTarget = config.tryFindDraggableTarget( e );\n\n    // If there is no such element, then nothing is being dragged; abort these\n    // steps, the drag-and-drop operation is never started.\n    if( !dragTarget ) {\n        console.log(\"dnd-poly: no draggable at touchstart coordinates\");\n        return;\n    }\n\n    try {\n        activeDragOperation = new DragOperationController( e, config, dragTarget as HTMLElement, dragOperationEnded );\n    }\n    catch( err ) {\n        dragOperationEnded( config, e, DragOperationState.CANCELLED );\n        // rethrow exception after cleanup\n        throw err;\n    }\n}\n\nfunction onDelayTouchstart( evt:TouchEvent ) {\n\n    console.log(\"dnd-poly: setup delayed dragstart..\");\n\n    const el = evt.target;\n\n    const heldItem = () => {\n\n        console.log(\"dnd-poly: starting delayed drag..\");\n\n        end.off();\n        cancel.off();\n        move.off();\n        scroll.off();\n        onTouchstart( evt );\n    };\n\n    const onReleasedItem = (event:Event) => {\n\n        console.log(\"dnd-poly: aborting delayed drag because of \" + event.type);\n\n        end.off();\n        cancel.off();\n        move.off();\n        scroll.off();\n\n        if (el) {\n            el.dispatchEvent(new CustomEvent(EVENT_DRAG_DRAGSTART_CANCEL, { bubbles: true, cancelable: true }));\n        }\n\n        clearTimeout( timer );\n    };\n\n    if (el) {\n        el.dispatchEvent(new CustomEvent(EVENT_DRAG_DRAGSTART_PENDING, { bubbles: true, cancelable: true }));\n    }\n\n    const timer = window.setTimeout( heldItem, config.holdToDrag );\n\n    const end = onEvt( el, \"touchend\", onReleasedItem );\n    const cancel = onEvt( el, \"touchcancel\", onReleasedItem );\n    const move = onEvt( el, \"touchmove\", onReleasedItem );\n    // scroll events don't bubble, only way to listen to scroll events\n    // that are about to happen in nested scrollables is by listening in capture phase\n    const scroll = onEvt( window, \"scroll\", onReleasedItem, true );\n}\n\n/**\n * Implements callback invoked when a drag operation has ended or crashed.\n */\nfunction dragOperationEnded( _config:Config, event:TouchEvent, state:DragOperationState ) {\n\n    // we need to make the default action happen only when no drag operation took place\n    if( state === DragOperationState.POTENTIAL ) {\n\n        console.log( \"dnd-poly: Drag never started. Last event was \" + event.type );\n\n        // when lifecycle hook is present\n        if( _config.defaultActionOverride ) {\n\n            try {\n\n                _config.defaultActionOverride( event );\n\n                if( event.defaultPrevented ) {\n\n                    console.log( \"dnd-poly: defaultActionOverride has taken care of triggering the default action. preventing default on original event\" );\n                }\n\n            }\n            catch( e ) {\n\n                console.log( \"dnd-poly: error in defaultActionOverride: \" + e );\n            }\n        }\n    }\n\n    // reset drag operation container\n    activeDragOperation = null;\n}\n\n//<editor-fold desc=\"public api\">\n\nexport { Point } from \"./internal/dom-utils\";\n\n// function signature for the dragImageTranslateOverride hook\nexport type DragImageTranslateOverrideFn = ( // corresponding touchmove event\n    event:TouchEvent,\n    // the processed touch event viewport coordinates\n    hoverCoordinates:Point,\n    // the element under the calculated touch coordinates\n    hoveredElement:HTMLElement,\n    // callback for updating the drag image offset\n    translateDragImageFn:( offsetX:number, offsetY:number ) => void ) => void;\n\nexport interface Config {\n\n    // flag to force the polyfill being applied and not rely on internal feature detection\n    forceApply?:boolean;\n\n    // useful for when you want the default drag image but still want to apply\n    // some static offset from touch coordinates to drag image coordinates\n    // defaults to (0,0)\n    dragImageOffset?:Point;\n\n    // if the dragImage shall be centered on the touch coordinates\n    // defaults to false\n    dragImageCenterOnTouch?:boolean;\n\n    // the drag and drop operation involves some processing. here you can specify in what interval this processing takes place.\n    // defaults to 150ms\n    iterationInterval?:number;\n\n    // hook for custom logic that decides if a drag operation should start\n    dragStartConditionOverride?:( event:TouchEvent ) => boolean;\n\n    // hook for custom logic that can manipulate the drag image translate offset\n    dragImageTranslateOverride?:DragImageTranslateOverrideFn;\n\n    // hook for custom logic that can override the default action based on the original touch event when the drag never started\n    // be sure to call event.preventDefault() if handling the default action in the override to prevent the browser default.\n    defaultActionOverride?:( event:TouchEvent ) => void;\n\n    // Drag action delay on touch devices (\"hold to drag\" functionality, useful for scrolling draggable items). Defaults to no delay.\n    holdToDrag?:number;\n\n    // function invoked for each touchstart event to determine if and which touched element is detected as \"draggable\"\n    tryFindDraggableTarget?:( event:TouchEvent ) => HTMLElement | undefined;\n\n    // function for creating a copy of the dragged element\n    dragImageSetup?:( element:HTMLElement ) => HTMLElement;\n\n    // function for determining element that is currently hovered while dragging\n    // defaults to `document.elementFromPoint()`\n    elementFromPoint?:( x:number, y:number ) => Element;\n}\n\nexport function polyfill( override?:Config ):boolean {\n\n    if( override ) {\n        // overwrite default config with user config\n        Object.keys( override ).forEach( function( key ) {\n            config[ key ] = override[ key ];\n        } );\n    }\n\n    // only do feature detection when config does not force apply the polyfill\n    if( !config.forceApply ) {\n\n        // feature/browser detection\n        const detectedFeatures = detectFeatures();\n\n        // if( DEBUG ) {\n        //     Object.keys( detectedFeatures ).forEach( function( key ) {\n        //         console.log( \"dnd-poly: detected feature '\" + key + \" = \" + detectedFeatures[ key ] + \"'\" );\n        //     } );\n        // }\n\n        // check if native drag and drop support is there\n        if( detectedFeatures.userAgentSupportingNativeDnD\n            && detectedFeatures.draggable\n            && detectedFeatures.dragEvents ) {\n            // no polyfilling required\n            return false;\n        }\n    }\n\n    console.log( \"dnd-poly: Applying mobile drag and drop polyfill.\" );\n\n    // add listeners suitable for detecting a potential drag operation\n    if( config.holdToDrag ) {\n        console.log(\"dnd-poly: holdToDrag set to \" + config.holdToDrag);\n        addDocumentListener( \"touchstart\", onDelayTouchstart, false );\n    } else {\n        addDocumentListener( \"touchstart\", onTouchstart, false );\n    }\n\n    return true;\n}\n\n//</editor-fold>\n","// debug mode, which will highlight drop target, immediate user selection and events fired as you interact\n// only available in non-minified js / development environment\n// export const DEBUG = false;\n\n// css classes\nexport const CLASS_PREFIX = \"dnd-poly-\";\nexport const CLASS_DRAG_IMAGE = CLASS_PREFIX + \"drag-image\";\nexport const CLASS_DRAG_IMAGE_SNAPBACK = CLASS_PREFIX + \"snapback\";\nexport const CLASS_DRAG_OPERATION_ICON = CLASS_PREFIX + \"icon\";\n\n// custom event\nexport const EVENT_PREFIX = \"dnd-poly-\";\nexport const EVENT_DRAG_DRAGSTART_PENDING = EVENT_PREFIX + \"dragstart-pending\";\nexport const EVENT_DRAG_DRAGSTART_CANCEL = EVENT_PREFIX + \"dragstart-cancel\";\n\n// defines the array indexes to access string in ALLOWED_EFFECTS\nexport const enum EFFECT_ALLOWED {\n    NONE = 0,\n    COPY = 1,\n    COPY_LINK = 2,\n    COPY_MOVE = 3,\n    LINK = 4,\n    LINK_MOVE = 5,\n    MOVE = 6,\n    ALL = 7\n}\n\n// contains all possible values of the effectAllowed property\nexport const ALLOWED_EFFECTS = [ \"none\", \"copy\", \"copyLink\", \"copyMove\", \"link\", \"linkMove\", \"move\", \"all\" ];\n\n// defines the array indexes to access string in DROP_EFFECTS\nexport const enum DROP_EFFECT {\n    NONE = 0,\n    COPY = 1,\n    MOVE = 2,\n    LINK = 3,\n}\n\n// contains all possible values of the dropEffect property\nexport const DROP_EFFECTS = [ \"none\", \"copy\", \"move\", \"link\" ];\n","export interface DetectedFeatures {\n    draggable:boolean;\n    dragEvents:boolean;\n    userAgentSupportingNativeDnD:boolean;\n}\n\nexport function detectFeatures():DetectedFeatures {\n\n    let features:DetectedFeatures = {\n        dragEvents: (\"ondragstart\" in document.documentElement),\n        draggable: (\"draggable\" in document.documentElement),\n        userAgentSupportingNativeDnD: undefined\n    };\n\n    const isBlinkEngine = !!((<any>window).chrome) || /chrome/i.test( navigator.userAgent );\n\n    features.userAgentSupportingNativeDnD = !(\n        // if is mobile safari or android browser -> no native dnd\n        (/iPad|iPhone|iPod|Android/.test( navigator.userAgent ))\n        || // OR\n        //if is blink(chrome/opera) with touch events enabled -> no native dnd\n        (isBlinkEngine && (\"ontouchstart\" in document.documentElement))\n    );\n\n    return features;\n}\n\nexport function supportsPassiveEventListener():boolean {\n\n    let supportsPassiveEventListeners = false;\n\n    // reference https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n    try {\n        let opts = Object.defineProperty( {}, \"passive\", {\n            get: function() {\n                supportsPassiveEventListeners = true;\n            }\n        } );\n        window.addEventListener( \"test\", null, opts );\n    }\n        // tslint:disable-next-line:no-empty\n    catch( e ) {\n    }\n\n    return supportsPassiveEventListeners;\n}\n","import { ALLOWED_EFFECTS, DROP_EFFECT, DROP_EFFECTS } from \"./constants\";\n\n/**\n * Polyfills https://html.spec.whatwg.org/multipage/interaction.html#drag-data-store-mode\n */\nexport const enum DragDataStoreMode {\n    _DISCONNECTED, // adding an extra mode here because we need a special state to disconnect the data store from dataTransfer instance\n    READONLY,\n    READWRITE,\n    PROTECTED\n}\n\n/**\n * Polyfills https://html.spec.whatwg.org/multipage/interaction.html#the-drag-data-store\n */\nexport interface DragDataStore {\n    mode:DragDataStoreMode;\n    data:{ [type:string]:any };\n    types:Array<string>;\n    effectAllowed:string;\n}\n\n/**\n * Polyfills https://html.spec.whatwg.org/multipage/interaction.html#datatransfer\n */\nexport class DataTransfer {\n\n    private _dropEffect:string = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n\n    public get dropEffect() {\n        return this._dropEffect;\n    }\n\n    //public get files():FileList {\n    //    return undefined;\n    //}\n    //\n    //public get items():DataTransferItemList {\n    //    return undefined;\n    //}\n\n    public set dropEffect( value ) {\n        if( this._dataStore.mode !== DragDataStoreMode._DISCONNECTED\n            && ALLOWED_EFFECTS.indexOf( value ) > -1 ) {\n            this._dropEffect = value;\n        }\n    }\n\n    public get types():ReadonlyArray<string> {\n        if( this._dataStore.mode !== DragDataStoreMode._DISCONNECTED ) {\n            return Object.freeze( this._dataStore.types );\n        }\n    }\n\n    public get effectAllowed() {\n        return this._dataStore.effectAllowed;\n    }\n\n    public set effectAllowed( value ) {\n        if( this._dataStore.mode === DragDataStoreMode.READWRITE\n            && ALLOWED_EFFECTS.indexOf( value ) > -1 ) {\n            this._dataStore.effectAllowed = value;\n        }\n    }\n\n    constructor( private _dataStore:DragDataStore,\n                 private _setDragImageHandler:( image:Element, x:number, y:number ) => void ) {\n    }\n\n    public setData( type:string, data:string ):void {\n        if( this._dataStore.mode === DragDataStoreMode.READWRITE ) {\n\n            if( type.indexOf( \" \" ) > -1 ) {\n                throw new Error( \"illegal arg: type contains space\" );\n            }\n\n            this._dataStore.data[ type ] = data;\n\n            if( this._dataStore.types.indexOf( type ) === -1 ) {\n                this._dataStore.types.push( type );\n            }\n        }\n    }\n\n    public getData( type:string ):string {\n        if( this._dataStore.mode === DragDataStoreMode.READONLY\n            || this._dataStore.mode === DragDataStoreMode.READWRITE ) {\n            return this._dataStore.data[ type ] || \"\";\n        }\n    }\n\n    public clearData( format?:string ):void {\n        if( this._dataStore.mode === DragDataStoreMode.READWRITE ) {\n            // delete data for format\n            if( format && this._dataStore.data[ format ] ) {\n                delete this._dataStore.data[ format ];\n                var index = this._dataStore.types.indexOf( format );\n                if( index > -1 ) {\n                    this._dataStore.types.splice( index, 1 );\n                }\n                return;\n            }\n            // delete all data\n            this._dataStore.data = {};\n            this._dataStore.types = [];\n        }\n    }\n\n    public setDragImage( image:Element, x:number, y:number ):void {\n        if( this._dataStore.mode === DragDataStoreMode.READWRITE ) {\n            this._setDragImageHandler( image, x, y );\n        }\n    }\n}\n","import { Config } from \"../index\";\nimport {\n    CLASS_DRAG_IMAGE, CLASS_DRAG_OPERATION_ICON, CLASS_PREFIX, DROP_EFFECT, DROP_EFFECTS\n} from \"./constants\";\nimport {\n    addDocumentListener, applyDragImageSnapback, extractTransformStyles, isDOMElement,\n    isTouchIdentifierContainedInTouchEvent, Point, removeDocumentListener, translateElementToPoint,\n    updateCentroidCoordinatesOfTouchesIn\n} from \"./dom-utils\";\nimport { DataTransfer, DragDataStore, DragDataStoreMode } from \"./drag-data-store\";\nimport { determineDragOperation, determineDropEffect, dispatchDragEvent } from \"./drag-utils\";\n\n/**\n * For tracking the different states of a drag operation.\n */\nexport const enum DragOperationState {\n    // initial state of a controller, if no movement is detected the operation ends with this state\n    POTENTIAL,\n    // after movement is detected the drag operation starts and keeps this state until it ends\n    STARTED,\n    // when the drag operation ended normally\n    ENDED,\n    // when the drag operation ended with a cancelled input event\n    CANCELLED\n}\n\n/**\n * Aims to implement the HTML5 d'n'd spec (https://html.spec.whatwg.org/multipage/interaction.html#dnd) as close as it can get.\n * Note that all props that are private should start with an underscore to enable better minification.\n *\n * TODO remove lengthy spec comments in favor of short references to the spec\n */\nexport class DragOperationController {\n\n    private _dragOperationState:DragOperationState = DragOperationState.POTENTIAL;\n\n    private _dragImage:HTMLElement;\n    private _dragImageTransforms:string[];\n    private _dragImagePageCoordinates:Point; // the current page coordinates of the dragImage\n    private _dragImageOffset:Point; // offset of the drag image relative to the coordinates\n\n    private _currentHotspotCoordinates:Point;    // the point relative to viewport for determining the immediate user selection\n\n    private _immediateUserSelection:HTMLElement = null;  // the element the user currently hovers while dragging\n    private _currentDropTarget:HTMLElement = null;   // the element that was selected as a valid drop target by the d'n'd operation\n\n    private _dragDataStore:DragDataStore;\n    private _dataTransfer:DataTransfer;\n\n    private _currentDragOperation:string;    // the current drag operation set according to the d'n'd processing model\n\n    private _initialTouch:Touch;  // the identifier for the touch that initiated the drag operation\n    private _touchMoveHandler:EventListener;\n    private _touchEndOrCancelHandler:EventListener;\n    private _lastTouchEvent:TouchEvent;\n\n    private _iterationLock:boolean;\n    private _iterationIntervalId:number;\n\n    constructor( private _initialEvent:TouchEvent,\n                 private _config:Config,\n                 private _sourceNode:HTMLElement,\n                 private _dragOperationEndedCb:( config:Config, event:TouchEvent, state:DragOperationState ) => void ) {\n\n        console.log( \"dnd-poly: setting up potential drag operation..\" );\n\n        this._lastTouchEvent = _initialEvent;\n        this._initialTouch = _initialEvent.changedTouches[ 0 ];\n\n        // create bound event listeners\n        this._touchMoveHandler = this._onTouchMove.bind( this );\n        this._touchEndOrCancelHandler = this._onTouchEndOrCancel.bind( this );\n        addDocumentListener( \"touchmove\", this._touchMoveHandler, false );\n        addDocumentListener( \"touchend\", this._touchEndOrCancelHandler, false );\n        addDocumentListener( \"touchcancel\", this._touchEndOrCancelHandler, false );\n\n        // the only thing we do is setup the touch listeners. if drag will really start is decided in touch move handler.\n\n        //<spec>\n\n        // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n        // 3. Establish which DOM node is the source node, as follows:\n        // If it is a selection that is being dragged, then the source node is the text node that the user started the drag on (typically the text node\n        // that the user originally clicked). If the user did not specify a particular node, for example if the user just told the user agent to begin\n        // a drag of \"the selection\", then the source node is the first text node containing a part of the selection.  Otherwise, if it is an element\n        // that is being dragged, then the source node is the element that is being dragged.  Otherwise, the source node is part of another document or\n        // application. When this specification requires that an event be dispatched at the source node in this case, the user agent must instead\n        // follow the platform-specific conventions relevant to that situation.\n\n        // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n        // 4. Determine the list of dragged nodes, as follows:\n\n        //    If it is a selection that is being dragged, then the list of dragged nodes contains, in tree order, every node that is partially or\n        // completely included in the selection (including all their ancestors).\n\n        //    Otherwise, the list of dragged nodes contains only the source node, if any.\n\n        // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n        // 5. If it is a selection that is being dragged, then add an item to the drag data store item list, with its properties set as follows:\n\n        //The drag data item type string\n        //\"text/plain\"\n        //The drag data item kind\n        //Plain Unicode string\n        //The actual data\n        //The text of the selection\n        //Otherwise, if any files are being dragged, then add one item per file to the drag data store item list, with their properties set as follows:\n        //\n        //The drag data item type string\n        //The MIME type of the file, if known, or \"application/octet-stream\" otherwise.\n        //    The drag data item kind\n        //File\n        //The actual data\n        //The file's contents and name.\n        //Dragging files can currently only happen from outside a browsing context, for example from a file system manager application.\n        //\n        //    If the drag initiated outside of the application, the user agent must add items to the drag data store item list as appropriate for the data\n        // being dragged, honoring platform conventions where appropriate; however, if the platform conventions do not use MIME types to label dragged\n        // data, the user agent must make a best-effort attempt to map the types to MIME types, and, in any case, all the drag data item type strings must\n        // be converted to ASCII lowercase.  Perform drag-and-drop initialization steps defined in any other applicable specifications.\n\n        //</spec>\n    }\n\n    //<editor-fold desc=\"setup/teardown\">\n\n    /**\n     * Setup dragImage, input listeners and the drag\n     * and drop process model iteration interval.\n     */\n    private _setup():boolean {\n        console.log( \"dnd-poly: starting drag and drop operation\" );\n\n        this._dragOperationState = DragOperationState.STARTED;\n\n        this._currentDragOperation = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n\n        this._dragDataStore = {\n            data: {},\n            effectAllowed: undefined,\n            mode: DragDataStoreMode.PROTECTED,\n            types: [],\n        };\n\n        this._currentHotspotCoordinates = {\n            x: null,\n            y: null\n        };\n\n        this._dragImagePageCoordinates = {\n            x: null,\n            y: null\n        };\n\n        let dragImageSrc:HTMLElement = this._sourceNode;\n\n        this._dataTransfer = new DataTransfer( this._dragDataStore, ( element:HTMLElement, x:number, y:number ) => {\n\n            dragImageSrc = element;\n\n            if( typeof x === \"number\" || typeof y === \"number\" ) {\n                this._dragImageOffset = {\n                    x: x || 0,\n                    y: y || 0\n                };\n            }\n        } );\n\n        // 9. Fire a DND event named dragstart at the source node.\n        this._dragDataStore.mode = DragDataStoreMode.READWRITE;\n        this._dataTransfer.dropEffect = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n        if( dispatchDragEvent( \"dragstart\", this._sourceNode, this._lastTouchEvent, this._dragDataStore, this._dataTransfer ) ) {\n            console.log( \"dnd-poly: dragstart cancelled\" );\n            // dragstart has been prevented -> cancel d'n'd\n            this._dragOperationState = DragOperationState.CANCELLED;\n            this._cleanup();\n            return false;\n        }\n\n        updateCentroidCoordinatesOfTouchesIn( \"page\", this._lastTouchEvent, this._dragImagePageCoordinates );\n        const dragImage = this._config.dragImageSetup( dragImageSrc );\n        this._dragImageTransforms = extractTransformStyles( dragImage );\n        // set layout styles for freely moving it around\n        dragImage.style.position = \"absolute\";\n        dragImage.style.left = \"0px\";\n        dragImage.style.top = \"0px\";\n        // on top of all\n        dragImage.style.zIndex = \"999999\";\n\n        // add polyfill class for default styling\n        dragImage.classList.add( CLASS_DRAG_IMAGE );\n        dragImage.classList.add( CLASS_DRAG_OPERATION_ICON );\n        this._dragImage = dragImage;\n\n        if( !this._dragImageOffset ) {\n\n            // apply specific offset\n            if( this._config.dragImageOffset ) {\n\n                this._dragImageOffset = {\n                    x: this._config.dragImageOffset.x,\n                    y: this._config.dragImageOffset.y\n                };\n            }\n            // center drag image on touch coordinates\n            else if( this._config.dragImageCenterOnTouch ) {\n\n                const cs = getComputedStyle( dragImageSrc );\n                this._dragImageOffset = {\n                    x: 0 - parseInt( cs.marginLeft, 10 ),\n                    y: 0 - parseInt( cs.marginTop, 10 )\n                };\n            }\n            // by default initialize drag image offset the same as desktop\n            else {\n\n                const targetRect = dragImageSrc.getBoundingClientRect();\n                const cs = getComputedStyle( dragImageSrc );\n                this._dragImageOffset = {\n                    x: targetRect.left - this._initialTouch.clientX - parseInt( cs.marginLeft, 10 ) + targetRect.width / 2,\n                    y: targetRect.top - this._initialTouch.clientY - parseInt( cs.marginTop, 10 ) + targetRect.height / 2\n                };\n            }\n        }\n\n        translateElementToPoint( this._dragImage, this._dragImagePageCoordinates, this._dragImageTransforms, this._dragImageOffset, this._config.dragImageCenterOnTouch );\n        document.body.appendChild( this._dragImage );\n\n        // 10. Initiate the drag-and-drop operation in a manner consistent with platform conventions, and as described below.\n        this._iterationIntervalId = window.setInterval( () => {\n\n            // If the user agent is still performing the previous iteration of the sequence (if any) when the next iteration becomes due,\n            // abort these steps for this iteration (effectively \"skipping missed frames\" of the drag-and-drop operation).\n            if( this._iterationLock ) {\n                console.log( \"dnd-poly: iteration skipped because previous iteration hast not yet finished.\" );\n                return;\n            }\n            this._iterationLock = true;\n\n            this._dragAndDropProcessModelIteration();\n\n            this._iterationLock = false;\n        }, this._config.iterationInterval );\n\n        return true;\n    }\n\n    private _cleanup() {\n\n        console.log( \"dnd-poly: cleanup\" );\n\n        if( this._iterationIntervalId ) {\n            clearInterval( this._iterationIntervalId );\n            this._iterationIntervalId = null;\n        }\n\n        removeDocumentListener( \"touchmove\", this._touchMoveHandler );\n        removeDocumentListener( \"touchend\", this._touchEndOrCancelHandler );\n        removeDocumentListener( \"touchcancel\", this._touchEndOrCancelHandler );\n\n        if( this._dragImage ) {\n            this._dragImage.parentNode.removeChild( this._dragImage );\n            this._dragImage = null;\n        }\n\n        this._dragOperationEndedCb( this._config, this._lastTouchEvent, this._dragOperationState );\n    }\n\n    //</editor-fold>\n\n    //<editor-fold desc=\"touch handlers\">\n\n    private _onTouchMove( event:TouchEvent ) {\n\n        // filter unrelated touches\n        if( isTouchIdentifierContainedInTouchEvent( event, this._initialTouch.identifier ) === false ) {\n            return;\n        }\n\n        // update the reference to the last received touch event\n        this._lastTouchEvent = event;\n\n        // drag operation did not start yet but on movement it should start\n        if( this._dragOperationState === DragOperationState.POTENTIAL ) {\n\n            let startDrag:boolean;\n\n            // is a lifecycle hook present?\n            if( this._config.dragStartConditionOverride ) {\n\n                try {\n                    startDrag = this._config.dragStartConditionOverride( event );\n                }\n                catch( e ) {\n                    console.error( \"dnd-poly: error in dragStartConditionOverride hook: \" + e );\n                    startDrag = false;\n                }\n            }\n            else {\n\n                // by default only allow a single moving finger to initiate a drag operation\n                startDrag = (event.touches.length === 1);\n            }\n\n            if( !startDrag ) {\n\n                this._cleanup();\n                return;\n            }\n\n            // setup will return true when drag operation starts\n            if( this._setup() === true ) {\n\n                // prevent scrolling when drag operation starts\n                this._initialEvent.preventDefault();\n                event.preventDefault();\n            }\n\n            return;\n        }\n\n        console.log( \"dnd-poly: moving draggable..\" );\n\n        // we emulate d'n'd so we dont want any defaults to apply\n        event.preventDefault();\n\n        // populate shared coordinates from touch event\n        updateCentroidCoordinatesOfTouchesIn( \"client\", event, this._currentHotspotCoordinates );\n        updateCentroidCoordinatesOfTouchesIn( \"page\", event, this._dragImagePageCoordinates );\n\n        if( this._config.dragImageTranslateOverride ) {\n\n            try {\n\n                let handledDragImageTranslate = false;\n\n                this._config.dragImageTranslateOverride(\n                    event,\n                    {\n                        x: this._currentHotspotCoordinates.x,\n                        y: this._currentHotspotCoordinates.y\n                    },\n                    this._immediateUserSelection,\n                    ( offsetX:number, offsetY:number ) => {\n\n                        // preventing translation of drag image when there was a drag operation cleanup meanwhile\n                        if( !this._dragImage ) {\n                            return;\n                        }\n\n                        handledDragImageTranslate = true;\n\n                        this._currentHotspotCoordinates.x += offsetX;\n                        this._currentHotspotCoordinates.y += offsetY;\n                        this._dragImagePageCoordinates.x += offsetX;\n                        this._dragImagePageCoordinates.y += offsetY;\n\n                        translateElementToPoint(\n                            this._dragImage,\n                            this._dragImagePageCoordinates,\n                            this._dragImageTransforms,\n                            this._dragImageOffset,\n                            this._config.dragImageCenterOnTouch\n                        );\n                    }\n                );\n\n                if( handledDragImageTranslate ) {\n                    return;\n                }\n            }\n            catch( e ) {\n                console.log( \"dnd-poly: error in dragImageTranslateOverride hook: \" + e );\n            }\n        }\n\n        translateElementToPoint( this._dragImage, this._dragImagePageCoordinates, this._dragImageTransforms, this._dragImageOffset, this._config.dragImageCenterOnTouch );\n    }\n\n    private _onTouchEndOrCancel( event:TouchEvent ) {\n\n        // filter unrelated touches\n        if( isTouchIdentifierContainedInTouchEvent( event, this._initialTouch.identifier ) === false ) {\n            return;\n        }\n\n        // let the dragImageTranslateOverride know that its over\n        if( this._config.dragImageTranslateOverride ) {\n            try {\n                /* tslint:disable */\n                this._config.dragImageTranslateOverride( undefined, undefined, undefined, function() {\n                } );\n            }\n            catch( e ) {\n                console.log( \"dnd-poly: error in dragImageTranslateOverride hook: \" + e );\n            }\n        }\n\n        // drag operation did not even start\n        if( this._dragOperationState === DragOperationState.POTENTIAL ) {\n            this._cleanup();\n            return;\n        }\n\n        // we emulate d'n'd so we dont want any defaults to apply\n        event.preventDefault();\n\n        this._dragOperationState = (event.type === \"touchcancel\") ? DragOperationState.CANCELLED : DragOperationState.ENDED;\n    }\n\n    //</editor-fold>\n\n    //<editor-fold desc=\"dnd spec logic\">\n\n    /**\n     * according to https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    private _dragAndDropProcessModelIteration():void {\n\n        // if( DEBUG ) {\n        //     var debug_class = CLASS_PREFIX + \"debug\",\n        //         debug_class_user_selection = CLASS_PREFIX + \"immediate-user-selection\",\n        //         debug_class_drop_target = CLASS_PREFIX + \"current-drop-target\";\n        // }\n\n        const previousDragOperation = this._currentDragOperation;\n\n        // Fire a DND event named drag event at the source node.\n        this._dragDataStore.mode = DragDataStoreMode.PROTECTED;\n        this._dataTransfer.dropEffect = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n        const dragCancelled = dispatchDragEvent( \"drag\", this._sourceNode, this._lastTouchEvent, this._dragDataStore, this._dataTransfer );\n        if( dragCancelled ) {\n            console.log( \"dnd-poly: drag event cancelled.\" );\n            // If this event is canceled, the user agent must set the current drag operation to \"none\" (no drag operation).\n            this._currentDragOperation = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n        }\n\n        // Otherwise, if the user ended the drag-and-drop operation (e.g. by releasing the mouse button in a mouse-driven drag-and-drop interface),\n        // or if the drag event was canceled, then this will be the last iteration.\n        if( dragCancelled || this._dragOperationState === DragOperationState.ENDED || this._dragOperationState === DragOperationState.CANCELLED ) {\n\n            const dragFailed = this._dragOperationEnded( this._dragOperationState );\n\n            // if drag failed transition snap back\n            if( dragFailed ) {\n\n                applyDragImageSnapback( this._sourceNode, this._dragImage, this._dragImageTransforms, () => {\n                    this._finishDragOperation();\n                } );\n                return;\n            }\n\n            // Otherwise immediately\n            // Fire a DND event named dragend at the source node.\n            this._finishDragOperation();\n            return;\n        }\n\n        // If the drag event was not canceled and the user has not ended the drag-and-drop operation,\n        // check the state of the drag-and-drop operation, as follows:\n        const newUserSelection:HTMLElement = <HTMLElement>this._config.elementFromPoint( this._currentHotspotCoordinates.x, this._currentHotspotCoordinates.y );\n\n        console.log( \"dnd-poly: new immediate user selection is: \" + newUserSelection );\n\n        const previousTargetElement = this._currentDropTarget;\n\n        // If the user is indicating a different immediate user selection than during the last iteration (or if this is the first iteration),\n        // and if this immediate user selection is not the same as the current target element,\n        // then fire a DND event named dragexit at the current target element,\n        // and then update the current target element as follows:\n        if( newUserSelection !== this._immediateUserSelection && newUserSelection !== this._currentDropTarget ) {\n\n            // if( DEBUG ) {\n            //\n            //     if( this._immediateUserSelection ) {\n            //         this._immediateUserSelection.classList.remove( debug_class_user_selection );\n            //     }\n            //\n            //     if( newUserSelection ) {\n            //         newUserSelection.classList.add( debug_class );\n            //         newUserSelection.classList.add( debug_class_user_selection );\n            //     }\n            // }\n\n            this._immediateUserSelection = newUserSelection;\n\n            if( this._currentDropTarget !== null ) {\n                this._dragDataStore.mode = DragDataStoreMode.PROTECTED;\n                this._dataTransfer.dropEffect = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n                dispatchDragEvent( \"dragexit\", this._currentDropTarget, this._lastTouchEvent, this._dragDataStore, this._dataTransfer, false );\n            }\n\n            // If the new immediate user selection is null\n            if( this._immediateUserSelection === null ) {\n                //Set the current target element to null also.\n                this._currentDropTarget = this._immediateUserSelection;\n\n                console.log( \"dnd-poly: current drop target changed to null\" );\n            }\n            // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n            // If the new immediate user selection is in a non-DOM document or application\n            // else if() {\n            //      Set the current target element to the immediate user selection.\n            //      this.currentDropTarget = this.immediateUserSelection;\n            //      return;\n            // }\n            // Otherwise\n            else {\n                // Fire a DND event named dragenter at the immediate user selection.\n                //the polyfill cannot determine if a handler even exists as browsers do to silently\n                // allow drop when no listener existed, so this event MUST be handled by the client\n                this._dragDataStore.mode = DragDataStoreMode.PROTECTED;\n                this._dataTransfer.dropEffect = determineDropEffect( this._dragDataStore.effectAllowed, this._sourceNode );\n                if( dispatchDragEvent( \"dragenter\", this._immediateUserSelection, this._lastTouchEvent, this._dragDataStore, this._dataTransfer ) ) {\n                    console.log( \"dnd-poly: dragenter default prevented\" );\n                    // If the event is canceled, then set the current target element to the immediate user selection.\n                    this._currentDropTarget = this._immediateUserSelection;\n                    this._currentDragOperation = determineDragOperation( this._dataTransfer.effectAllowed, this._dataTransfer.dropEffect );\n                }\n                // Otherwise, run the appropriate step from the following list:\n                else {\n\n                    // NO DROPZONE SUPPORT SINCE NATIVE IMPLEMENTATIONS IN BROWSERS ALSO DO NOT\n                    //console.log( \"dnd-poly: dragenter not prevented, searching for dropzone..\" );\n                    //var newTarget = DragOperationController.FindDropzoneElement( this.immediateUserSelection );\n\n                    // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n                    // If the current target element is a text field (e.g. textarea, or an input element whose type attribute is in the Text state) or an\n                    // editable element, and the drag data store item list has an item with the drag data item type string \"text/plain\" and the drag data\n                    // item kind Plain Unicode string\n                    //if( ElementIsTextDropzone( this.immediateUserSelection, this.dragDataStore ) ) {\n                    //Set the current target element to the immediate user selection anyway.\n                    //this.currentDropTarget = this.immediateUserSelection;\n                    //}\n                    //else\n                    // If the current target element is an element with a dropzone attribute that matches the drag data store\n                    //if( newTarget === this.immediateUserSelection &&\n                    //    DragOperationController.GetOperationForMatchingDropzone( this.immediateUserSelection, this.dragDataStore ) !== \"none\" ) {\n                    // Set the current target element to the immediate user selection anyway.\n                    //    this.currentDropTarget = this.immediateUserSelection;\n                    //}\n                    // If the immediate user selection is an element that itself has an ancestor element\n                    // with a dropzone attribute that matches the drag data store\n                    // NO DROPZONE SUPPORT SINCE NATIVE IMPLEMENTATIONS IN BROWSERS ALSO DO NOT\n                    //else if( newTarget !== null && DragOperationController.GetOperationForMatchingDropzone( newTarget, this.dragDataStore ) ) {\n\n                    // If the immediate user selection is new target, then leave the current target element unchanged.\n\n                    // Otherwise, fire a DND event named dragenter at new target, with the current target element\n                    // as the specific related target. Then, set the current target element to new target,\n                    // regardless of whether that event was canceled or not.\n                    //this.dragenter( newTarget, this.currentDropTarget );\n                    //this.currentDropTarget = newTarget;\n                    //}\n                    // If the current target element is not the body element\n                    //else\n                    if( this._immediateUserSelection !== document.body ) {\n                        // Fire a DND event named dragenter at the body element, and set the current target element to the body element, regardless of\n                        // whether that event was canceled or not.\n                        // Note: If the body element is null, then the event will be fired at the Document object (as\n                        // required by the definition of the body element), but the current target element would be set to null, not the Document object.\n\n                        // We do not listen to what the spec says here because this results in doubled events on the body/document because if the first one\n                        // was not cancelled it will have bubbled up to the body already ;)\n                        //  this.dragenter( window.document.body );\n                        this._currentDropTarget = document.body;\n                    }\n                    // Otherwise\n                    //else {\n                    // leave the current drop target unchanged\n                    //}\n                }\n            }\n        }\n\n        // If the previous step caused the current target element to change,\n        // and if the previous target element was not null or a part of a non-DOM document,\n        // then fire a DND event named dragleave at the previous target element.\n        if( previousTargetElement !== this._currentDropTarget && (isDOMElement( previousTargetElement )) ) {\n\n            // if( DEBUG ) {\n            //     previousTargetElement.classList.remove( debug_class_drop_target );\n            // }\n\n            console.log( \"dnd-poly: current drop target changed.\" );\n\n            this._dragDataStore.mode = DragDataStoreMode.PROTECTED;\n            this._dataTransfer.dropEffect = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n            dispatchDragEvent( \"dragleave\", previousTargetElement, this._lastTouchEvent, this._dragDataStore, this._dataTransfer, false, this._currentDropTarget );\n        }\n\n        // If the current target element is a DOM element, then fire a DND event named dragover at this current target element.\n        if( isDOMElement( this._currentDropTarget ) ) {\n\n            // if( DEBUG ) {\n            //     this._currentDropTarget.classList.add( debug_class );\n            //     this._currentDropTarget.classList.add( debug_class_drop_target );\n            // }\n\n            // If the dragover event is not canceled, run the appropriate step from the following list:\n            this._dragDataStore.mode = DragDataStoreMode.PROTECTED;\n            this._dataTransfer.dropEffect = determineDropEffect( this._dragDataStore.effectAllowed, this._sourceNode );\n            if( dispatchDragEvent( \"dragover\", this._currentDropTarget, this._lastTouchEvent, this._dragDataStore, this._dataTransfer ) === false ) {\n\n                console.log( \"dnd-poly: dragover not prevented on possible drop-target.\" );\n                // NO DROPZONE SUPPORT SINCE NATIVE IMPLEMENTATIONS IN BROWSERS ALSO DO NOT\n\n                // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n                // If the current target element is a text field (e.g. textarea, or an input element whose type attribute is in the Text state) or\n                // an editable element, and the drag data store item list has an item with the drag data item type string \"text/plain\" and the drag\n                // data item kind Plain Unicode string\n                //if( ElementIsTextDropzone( this.currentDropTarget, this.dragDataStore ) ) {\n                // Set the current drag operation to either \"copy\" or \"move\", as appropriate given the platform conventions.\n                //this.currentDragOperation = \"copy\"; //or move. spec says its platform specific behaviour.\n                //}\n                //else {\n                // If the current target element is an element with a dropzone attribute that matches the drag data store\n                //this.currentDragOperation = DragOperationController.GetOperationForMatchingDropzone( this.currentDropTarget, this.dragDataStore );\n                //}\n                // when dragover is not prevented and no dropzones are there, no drag operation\n                this._currentDragOperation = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n            }\n            // Otherwise (if the dragover event is canceled), set the current drag operation based on the values of the effectAllowed and\n            // dropEffect attributes of the DragEvent object's dataTransfer object as they stood after the event dispatch finished\n            else {\n\n                console.log( \"dnd-poly: dragover prevented.\" );\n\n                this._currentDragOperation = determineDragOperation( this._dataTransfer.effectAllowed, this._dataTransfer.dropEffect );\n            }\n        }\n\n        console.log( \"dnd-poly: d'n'd iteration ended. current drag operation: \" + this._currentDragOperation );\n\n        // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n        // Otherwise, if the current target element is not a DOM element, use platform-specific mechanisms to determine what drag operation is\n        // being performed (none, copy, link, or move), and set the current drag operation accordingly.\n\n        //Update the drag feedback (e.g. the mouse cursor) to match the current drag operation, as follows:\n        // ---------------------------------------------------------------------------------------------------------\n        // Drag operation   |\tFeedback\n        // \"copy\"\t        |  Data will be copied if dropped here.\n        // \"link\"\t        |  Data will be linked if dropped here.\n        // \"move\"\t        |  Data will be moved if dropped here.\n        // \"none\"\t        |  No operation allowed, dropping here will cancel the drag-and-drop operation.\n        // ---------------------------------------------------------------------------------------------------------\n\n        if( previousDragOperation !== this._currentDragOperation ) {\n            this._dragImage.classList.remove( CLASS_PREFIX + previousDragOperation );\n        }\n\n        const currentDragOperationClass = CLASS_PREFIX + this._currentDragOperation;\n\n        this._dragImage.classList.add( currentDragOperationClass );\n    }\n\n    /**\n     * according to https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    private _dragOperationEnded( state:DragOperationState ):boolean {\n\n        console.log( \"dnd-poly: drag operation end detected with \" + this._currentDragOperation );\n\n        // if( DEBUG ) {\n        //\n        //     var debug_class_user_selection = CLASS_PREFIX + \"immediate-user-selection\",\n        //         debug_class_drop_target = CLASS_PREFIX + \"current-drop-target\";\n        //\n        //     if( this._currentDropTarget ) {\n        //         this._currentDropTarget.classList.remove( debug_class_drop_target );\n        //\n        //     }\n        //     if( this._immediateUserSelection ) {\n        //         this._immediateUserSelection.classList.remove( debug_class_user_selection );\n        //     }\n        // }\n\n        //var dropped:boolean = undefined;\n\n        // Run the following steps, then stop the drag-and-drop operation:\n\n        // If the current drag operation is \"none\" (no drag operation), or,\n        // if the user ended the drag-and-drop operation by canceling it (e.g. by hitting the Escape key), or\n        // if the current target element is null, then the drag operation failed.\n        const dragFailed = (this._currentDragOperation === DROP_EFFECTS[ DROP_EFFECT.NONE ]\n            || this._currentDropTarget === null\n            || state === DragOperationState.CANCELLED);\n        if( dragFailed ) {\n\n            // Run these substeps:\n\n            // Let dropped be false.\n            //dropped = false;\n\n            // If the current target element is a DOM element, fire a DND event named dragleave at it;\n            if( isDOMElement( this._currentDropTarget ) ) {\n                this._dragDataStore.mode = DragDataStoreMode.PROTECTED;\n                this._dataTransfer.dropEffect = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n                dispatchDragEvent( \"dragleave\", this._currentDropTarget, this._lastTouchEvent, this._dragDataStore, this._dataTransfer, false );\n            }\n\n            // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n            // otherwise, if it is not null, use platform-specific conventions for drag cancellation.\n            //else if( this.currentDropTarget !== null ) {\n            //}\n        }\n        // Otherwise, the drag operation was as success; run these substeps:\n        else {\n\n            // Let dropped be true.\n            //dropped = true;\n\n            // If the current target element is a DOM element, fire a DND event named drop at it;\n            if( isDOMElement( this._currentDropTarget ) ) {\n\n                // If the event is canceled, set the current drag operation to the value of the dropEffect attribute of the\n                // DragEvent object's dataTransfer object as it stood after the event dispatch finished.\n\n                this._dragDataStore.mode = DragDataStoreMode.READONLY;\n                this._dataTransfer.dropEffect = this._currentDragOperation;\n                if( dispatchDragEvent( \"drop\", this._currentDropTarget, this._lastTouchEvent, this._dragDataStore, this._dataTransfer ) ===\n                    true ) {\n\n                    this._currentDragOperation = this._dataTransfer.dropEffect;\n                }\n                // Otherwise, the event is not canceled; perform the event's default action, which depends on the exact target as follows:\n                else {\n\n                    // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n                    // If the current target element is a text field (e.g. textarea, or an input element whose type attribute is in the Text state)\n                    // or an editable element,\n                    // and the drag data store item list has an item with the drag data item type string \"text/plain\"\n                    // and the drag data item kind Plain Unicode string\n                    //if( ElementIsTextDropzone( this.currentDropTarget, this.dragDataStore ) ) {\n                    // Insert the actual data of the first item in the drag data store item list to have a drag data item type string of\n                    // \"text/plain\" and a drag data item kind that is Plain Unicode string into the text field or editable element in a manner\n                    // consistent with platform-specific conventions (e.g. inserting it at the current mouse cursor position, or inserting it at\n                    // the end of the field).\n                    //}\n                    // Otherwise\n                    //else {\n                    // Reset the current drag operation to \"none\".\n                    this._currentDragOperation = DROP_EFFECTS[ DROP_EFFECT.NONE ];\n                    //}\n                }\n            }\n            // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n            // otherwise, use platform-specific conventions for indicating a drop.\n            //else {\n            //}\n        }\n\n        return dragFailed;\n\n        // THIS IS SKIPPED SINCE SUPPORT IS ONLY AVAILABLE FOR DOM ELEMENTS\n        //if( this.dragend( this.sourceNode ) ) {\n        //    return;\n        //}\n\n        // Run the appropriate steps from the following list as the default action of the dragend event:\n\n        //if( !dropped ) {\n        //    return;\n        //}\n        // dropped is true\n\n        //if( this.currentDragOperation !== \"move\" ) {\n        //    return;\n        //}\n        //// drag operation is move\n        //\n        //if( ElementIsTextDropzone( this.currentDropTarget ) === false ) {\n        //    return;\n        //}\n        //// element is textfield\n        //\n        //// and the source of the drag-and-drop operation is a selection in the DOM\n        //if( this.sourceNode.nodeType === 1 ) {\n        //    // The user agent should delete the range representing the dragged selection from the DOM.\n        //}\n        //// and the source of the drag-and-drop operation is a selection in a text field\n        //else if( this.sourceNode.nodeType === 3 ) {\n        //    // The user agent should delete the dragged selection from the relevant text field.\n        //}\n        //// Otherwise, The event has no default action.\n    }\n\n    // dispatch dragend event and cleanup drag operation\n    private _finishDragOperation():void {\n        console.log( \"dnd-poly: dragimage snap back transition ended\" );\n\n        // Fire a DND event named dragend at the source node.\n        this._dragDataStore.mode = DragDataStoreMode.PROTECTED;\n        this._dataTransfer.dropEffect = this._currentDragOperation;\n        dispatchDragEvent( \"dragend\", this._sourceNode, this._lastTouchEvent, this._dragDataStore, this._dataTransfer, false );\n\n        // drag operation over and out\n        this._dragOperationState = DragOperationState.ENDED;\n        this._cleanup();\n    }\n\n    //</editor-fold>\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"card\":\"card__3mJh1\"};","//<editor-fold desc=\"static scroll utils\">\n\nimport { DragImageTranslateOverrideFn } from \"./index\";\nimport { Point } from \"./internal/dom-utils\";\n\ninterface ScrollIntentions {\n    horizontal:ScrollIntention;\n    vertical:ScrollIntention;\n}\n\ninterface IScrollBounds {\n    x:number;\n    y:number;\n    width:number;\n    height:number;\n    scrollX:number;\n    scrollY:number;\n    scrollHeight:number;\n    scrollWidth:number;\n}\n\nconst enum ScrollIntention {\n    NONE = 0,\n    LEFT_OR_TOP = -1,\n    RIGHT_OR_BOTTOM = 1\n}\n\nconst enum ScrollAxis {\n    HORIZONTAL,\n    VERTICAL\n}\n\nfunction isTopLevelEl( el:HTMLElement ):boolean {\n\n    return (el === document.body || el === document.documentElement);\n}\n\nfunction getElementViewportOffset( el:HTMLElement, axis:ScrollAxis ) {\n    let offset:number;\n\n    if( isTopLevelEl( el ) ) {\n        offset = (axis === ScrollAxis.HORIZONTAL) ? el.clientLeft : el.clientTop;\n    }\n    else {\n        const bounds = el.getBoundingClientRect();\n        offset = (axis === ScrollAxis.HORIZONTAL) ? bounds.left : bounds.top;\n    }\n\n    return offset;\n}\n\nfunction getElementViewportSize( el:HTMLElement, axis:ScrollAxis ) {\n    let size:number;\n\n    if( isTopLevelEl( el ) ) {\n        size = (axis === ScrollAxis.HORIZONTAL) ? window.innerWidth : window.innerHeight;\n    }\n    else {\n        size = (axis === ScrollAxis.HORIZONTAL) ? el.clientWidth : el.clientHeight;\n    }\n\n    return size;\n}\n\nfunction getSetElementScroll( el:HTMLElement, axis:ScrollAxis, scroll?:number ) {\n    const prop = (axis === ScrollAxis.HORIZONTAL) ? \"scrollLeft\" : \"scrollTop\";\n\n    // abstracting away compatibility issues on scroll properties of document/body\n    const isTopLevel = isTopLevelEl( el );\n\n    if( arguments.length === 2 ) {\n\n        if( isTopLevel ) {\n            return document.body[ prop ] || document.documentElement[ prop ];\n        }\n\n        return el[ prop ];\n    }\n\n    if( isTopLevel ) {\n        document.documentElement[ prop ] += scroll;\n        document.body[ prop ] += scroll;\n    }\n    else {\n        el[ prop ] += scroll;\n    }\n}\n\n//TODO check if scroll end is reached according to scroll intention? this is needed to implement scroll chaining\nfunction isScrollable( el:HTMLElement ):boolean {\n    const cs = getComputedStyle( el );\n\n    if( el.scrollHeight > el.clientHeight && (cs.overflowY === \"scroll\" || cs.overflowY === \"auto\") ) {\n        return true;\n    }\n\n    if( el.scrollWidth > el.clientWidth && (cs.overflowX === \"scroll\" || cs.overflowX === \"auto\") ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction findScrollableParent( el:HTMLElement ):HTMLElement {\n    do {\n        if( !el ) {\n            return undefined;\n        }\n        if( isScrollable( el ) ) {\n            return el;\n        }\n        if( el === document.documentElement ) {\n            return null;\n        }\n    } while( el = <HTMLElement>el.parentNode );\n    return null;\n}\n\nfunction determineScrollIntention( currentCoordinate:number, size:number, threshold:number ):ScrollIntention {\n\n    // LEFT / TOP\n    if( currentCoordinate < threshold ) {\n        return ScrollIntention.LEFT_OR_TOP;\n    }\n    // RIGHT / BOTTOM\n    else if( size - currentCoordinate < threshold ) {\n        return ScrollIntention.RIGHT_OR_BOTTOM;\n    }\n    // NONE\n    return ScrollIntention.NONE;\n}\n\nfunction determineDynamicVelocity( scrollIntention:ScrollIntention, currentCoordinate:number, size:number, threshold:number ):number {\n\n    if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\n\n        return Math.abs( currentCoordinate - threshold );\n    }\n    else if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\n\n        return Math.abs( size - currentCoordinate - threshold );\n    }\n\n    return 0;\n}\n\nfunction isScrollEndReached( axis:ScrollAxis, scrollIntention:ScrollIntention, scrollBounds:IScrollBounds ) {\n\n    const currentScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollX) : (scrollBounds.scrollY);\n\n    // wants to scroll to the right/bottom\n    if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\n\n        const maxScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollWidth - scrollBounds.width) : (scrollBounds.scrollHeight -\n            scrollBounds.height);\n\n        // is already at the right/bottom edge\n        return currentScrollOffset >= maxScrollOffset;\n    }\n    // wants to scroll to the left/top\n    else if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\n\n        // is already at left/top edge\n        return (currentScrollOffset <= 0);\n    }\n    // no scroll\n    return true;\n}\n\n//</editor-fold>\n\nlet _options:ScrollOptions = {\n    threshold: 75,\n    // simplified cubic-ease-in function\n    velocityFn: function( velocity:number, threshold:number ) {\n        const multiplier = velocity / threshold;\n        const easeInCubic = multiplier * multiplier * multiplier;\n        return easeInCubic * threshold;\n    }\n};\n\nlet _scrollIntentions:ScrollIntentions = {\n    horizontal: ScrollIntention.NONE,\n    vertical: ScrollIntention.NONE\n};\n\nlet _dynamicVelocity:Point = {\n    x: 0,\n    y: 0\n};\n\nlet _scrollAnimationFrameId:any;\nlet _currentCoordinates:Point;\nlet _hoveredElement:HTMLElement;\nlet _scrollableParent:HTMLElement;\nlet _translateDragImageFn:( offsetX:number, offsetY:number ) => void;\n\n/**\n * core handler function\n */\nfunction handleDragImageTranslateOverride( event:TouchEvent,\n                                           currentCoordinates:Point,\n                                           hoveredElement:HTMLElement,\n                                           translateDragImageFn:( scrollDiffX:number, scrollDiffY:number ) => void ):void {\n\n    _currentCoordinates = currentCoordinates;\n    _translateDragImageFn = translateDragImageFn;\n\n    // update parent if hovered element changed\n    if( _hoveredElement !== hoveredElement ) {\n\n        _hoveredElement = hoveredElement;\n        _scrollableParent = findScrollableParent( _hoveredElement );\n    }\n\n    // update scroll intention and check if we should scroll at all\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    const performScrollAnimation = updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity );\n\n    // no animation in progress but scroll is intended\n    if( performScrollAnimation ) {\n\n        // setup scroll animation frame\n        scheduleScrollAnimation();\n    }\n    else if( !!_scrollAnimationFrameId ) {\n\n        window.cancelAnimationFrame( _scrollAnimationFrameId );\n        _scrollAnimationFrameId = null;\n    }\n}\n\n//<editor-fold desc=\"programmatic scroll animation frame handler\">\n\nfunction scheduleScrollAnimation() {\n\n    // prevent scheduling when already scheduled\n    if( !!_scrollAnimationFrameId ) {\n\n        return;\n    }\n\n    _scrollAnimationFrameId = window.requestAnimationFrame( scrollAnimation );\n}\n\nfunction scrollAnimation() {\n\n    let scrollDiffX = 0,\n        scrollDiffY = 0,\n        isTopLevel = isTopLevelEl( _scrollableParent );\n\n    if( _scrollIntentions.horizontal !== ScrollIntention.NONE ) {\n\n        scrollDiffX = Math.round( _options.velocityFn( _dynamicVelocity.x, _options.threshold ) * _scrollIntentions.horizontal );\n        getSetElementScroll( _scrollableParent, ScrollAxis.HORIZONTAL, scrollDiffX );\n    }\n\n    if( _scrollIntentions.vertical !== ScrollIntention.NONE ) {\n\n        scrollDiffY = Math.round( _options.velocityFn( _dynamicVelocity.y, _options.threshold ) * _scrollIntentions.vertical );\n        getSetElementScroll( _scrollableParent, ScrollAxis.VERTICAL, scrollDiffY );\n    }\n\n    if( isTopLevel ) {\n        // on top level element scrolling we need to translate the drag image as much as we scroll\n        _translateDragImageFn( scrollDiffX, scrollDiffY );\n    }\n    else {\n        // just scroll the container and update the drag image position without offset\n        _translateDragImageFn( 0, 0 );\n    }\n\n    // reset to make sure we can re-schedule scroll animation\n    _scrollAnimationFrameId = null;\n\n    // check if we should continue scrolling\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    if( updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity ) ) {\n\n        // re-schedule animation frame callback\n        scheduleScrollAnimation();\n    }\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"scroll checks\">\n\nfunction updateScrollIntentions( currentCoordinates:Point,\n                                 scrollableParent:HTMLElement,\n                                 threshold:number,\n                                 scrollIntentions:ScrollIntentions,\n                                 dynamicVelocity:Point ):boolean {\n\n    if( !currentCoordinates || !scrollableParent ) {\n\n        // when coordinates become undefined drag operation stopped. stop scrolling also.\n        return false;\n    }\n\n    const scrollableParentBounds:IScrollBounds = {\n        x: getElementViewportOffset( scrollableParent, ScrollAxis.HORIZONTAL ),\n        y: getElementViewportOffset( scrollableParent, ScrollAxis.VERTICAL ),\n        width: getElementViewportSize( scrollableParent, ScrollAxis.HORIZONTAL ),\n        height: getElementViewportSize( scrollableParent, ScrollAxis.VERTICAL ),\n        scrollX: getSetElementScroll( scrollableParent, ScrollAxis.HORIZONTAL ),\n        scrollY: getSetElementScroll( scrollableParent, ScrollAxis.VERTICAL ),\n        scrollWidth: scrollableParent.scrollWidth,\n        scrollHeight: scrollableParent.scrollHeight\n    };\n\n    const currentCoordinatesOffset = {\n        x: currentCoordinates.x - scrollableParentBounds.x,\n        y: currentCoordinates.y - scrollableParentBounds.y\n    };\n\n    scrollIntentions.horizontal = determineScrollIntention( currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\n    scrollIntentions.vertical = determineScrollIntention( currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\n\n    if( scrollIntentions.horizontal && isScrollEndReached( ScrollAxis.HORIZONTAL, scrollIntentions.horizontal, scrollableParentBounds ) ) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.horizontal = ScrollIntention.NONE;\n    }\n    else if( scrollIntentions.horizontal ) {\n\n        dynamicVelocity.x = determineDynamicVelocity( scrollIntentions.horizontal, currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\n    }\n\n    if( scrollIntentions.vertical && isScrollEndReached( ScrollAxis.VERTICAL, scrollIntentions.vertical, scrollableParentBounds ) ) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.vertical = ScrollIntention.NONE;\n    }\n    else if( scrollIntentions.vertical ) {\n\n        dynamicVelocity.y = determineDynamicVelocity( scrollIntentions.vertical, currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\n    }\n\n    return !!(scrollIntentions.horizontal || scrollIntentions.vertical);\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"public api\">\n\nexport interface ScrollOptions {\n    // threshold in px. when distance between scrollable element edge and touch position is smaller start programmatic scroll.\n    // defaults to 75px\n    threshold?:number;\n    // function to customize the scroll velocity\n    // velocity param: distance to scrollable element edge\n    // threshold: the threshold used to determine when scrolling should start\n    // defaults to cubic-ease-in.\n    velocityFn:( velocity:number, threshold:number ) => number;\n}\n\nexport const scrollBehaviourDragImageTranslateOverride:DragImageTranslateOverrideFn = handleDragImageTranslateOverride;\n\n//</editor-fold>\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"btn\":\"btn__ove9P\",\"btn-icon\":\"btn-icon__3KkgF\",\"btn-primary\":\"btn-primary__1R6Z0\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"editor\":\"editor__1I80g\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"japanese-text\":\"japanese-text__1TNcs\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"preview\":\"preview__2K3aJ\"};"],"sourceRoot":""}